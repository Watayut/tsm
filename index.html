<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tsm: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tsm
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">tsm Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>For a primer on UML state machines, look <a href="https://en.wikipedia.org/wiki/UML_state_machine">here</a>.</p>
<h4>Using tsm</h4>
<p>Create the state machine definition (HsmDef). </p><div class="fragment"><div class="line">struct GarageDoorDef : public HsmDefinition&lt;GarageDoorDef&gt;</div><div class="line">{</div><div class="line">   GarageDoorDef(State* parent = nullptr)</div><div class="line">     : HsmDefinition&lt;GarageDoorDef&gt;(parent)</div><div class="line">     , name(&quot;Garage Door Hsm&quot;)</div><div class="line">     , doorOpen(&quot;Door Open&quot;)</div><div class="line">     ...</div><div class="line">   {</div><div class="line">       // TransitionTable</div><div class="line">       add(doorClosed, click_event, doorOpening);</div><div class="line">       add(doorOpening, topSensor_event, doorOpen);</div><div class="line">       ...</div><div class="line">   }</div><div class="line"></div><div class="line">   State* getStartState() const { return &amp;doorClosed; }</div><div class="line"></div><div class="line">   State* getStopState() const { return nullptr; }</div><div class="line"></div><div class="line"></div><div class="line">   // States</div><div class="line">   State doorOpen;</div><div class="line">   State doorOpening;</div><div class="line">   ...</div><div class="line">   // Events</div><div class="line">   Event click_event;</div><div class="line">   ...</div><div class="line">};</div></div><!-- fragment --><p> Make sure that the getStartState and getStopState methods are overridden in the HsmDef.</p>
<p>Wrap the definition around a statemachine and then around an execution policy. Here we have two options.</p>
<p>a. Create a state machine that executes in the context of the parent thread. </p><div class="fragment"><div class="line">SingleThreadedHsm&lt;GarageDoorDef&gt; sm;</div></div><!-- fragment --><p>b. Create a state machine that processes incomming events in its own thread. </p><div class="fragment"><div class="line">AsyncExecutionPolicy&lt;GarageDoorDef&gt; sm;</div></div><!-- fragment --><p>c. Send events to the state machine by using sendEvent method provided by the policy. </p><div class="fragment"><div class="line">sm.sendEvent(sm.doorOpen);</div></div><!-- fragment --><p>d. If the state machine is running in parent thread context, invoke the <code>step</code> method to process the first event in the event queue. The <code>AsyncExecutionPolicy</code> will immediately process an event on completion of prior event processing.</p>
<p>For a complete example see <a href="https://github.com/tinverse/tsm/blob/master/test/GarageDoorDef.h">GarageDoorDef.h</a> and <a href="https://github.com/tinverse/tsm/blob/master/test/GarageDoorDef.cpp">GarageDoorDef.cpp</a>. Also look at <a href="https://github.com/tinverse/tsm/blob/master/test/CdPlayerHsm.h">CdPlayerHsm.h</a> <a href="https://github.com/tinverse/tsm/blob/master/test/CdPlayerHsm.cpp">CdPlayerHsm.cpp</a></p>
<div class="fragment"><div class="line">sm.step();</div></div><!-- fragment --><h3>Architecture</h3>
<h4>Policy based design</h4>
<p>Classes have been partitioned across policies so they can be mixed and matched for code reuse. The current architecture supports state machines with the following characterestics. </p><div class="fragment"><div class="line">a. Hierarchical</div><div class="line">b. Asynchronous</div><div class="line">c. Parallel/Orthogonal</div><div class="line">d. History Preserving</div></div><!-- fragment --><p>Other Policy classes can be implemented for distributed event processing. The existing mechanism can also be extended to incorporate custom behavior such as writing state transitions to disk. For e.g. see <code>struct AsyncExecWithObserver</code> in <code><a class="el" href="AsyncExecutionPolicy_8h.html">AsyncExecutionPolicy.h</a></code></p>
<p>Clients need to include <a class="el" href="tsm_8h.html">tsm.h</a> file and link against the libtsm library.</p>
<p>The abstract base class <code>IHsmDef</code> forces all Hierarchical State Machines to override the <code>getStartState</code> and <code>getStopState</code> methods.</p>
<p>The design uses CRTP to force Actions and Guards to be callbacks that are part of your Hsm class. See the implementation of</p>
<div class="fragment"><div class="line">  template &lt;typename HsmDef&gt;</div><div class="line">  struct HsmDefinition : public IHsmDef {</div><div class="line">  ...</div><div class="line">};</div></div><!-- fragment --> <h4>HsmDef</h4>
<p>Place holder for your own application specific sate machine definition. For e.g. you might create your own Hsm called <code>CdPlayerHsm</code>. This Hsm should inherit from <code>HsmDefinition</code> using CRTP.</p>
<div class="fragment"><div class="line">  struct CdPlayerHsm : public HsmDefinition&lt;CdPlayerHsm&gt; {</div><div class="line">  ...</div><div class="line">};</div></div><!-- fragment --><h4>HsmDefinition</h4>
<p>HsmDefinition is a generic that takes a user defined Hsm as a template type parameter. Inheriting from <code>HsmDefinition</code> gives your state machine type - in this case the <code>CdPlayerHsm</code>, a <code>StateTransitionTable</code> class and associated boiler plate functionality for performing state transitions.</p>
<h4>StateMachine</h4>
<p>The <code>StateMachine</code> generic implements functionality that is common to all Hsms. It provides methods <code>startSM</code> and <code>stopSM</code> that are self explanatory. The <code>dispatch</code> method forwards the event to be processed to the innermost Hsm. In one of he policy classes, <code>execute</code> is then invoked on that (innermost) Hsm. See <code>AsyncExecutionPolicy::processEvent</code>.</p>
<h4>Policy Classes</h4>
<p>Policy classes like <code>AsyncExecutionPolicy</code> and <code>SingleThreadedExecutionPolicy</code> are mixins that operate on <code>StateType</code>s i.e. any type with <code>onEntry</code> and <code>onExit</code> methods that can be overridden. Clients will typically interact with a Policy class at the bottom of the inheritance hierarcy. By convention, these Policy classes also provide a <code>sendEvent</code> method as a public interface to the state machine. The <code>SingleThreadedExecutionPolicy</code> class also provides a <code>step</code> method for clients to initiate event processing.</p>
<p>The <code>AsyncExecutionPolicy</code> processes events in it's own thread. The processing of events is single threaded within all Hsms. So when a Hsm is started using a call to <code>startSM</code>, the <code>StateMachine</code> will block on the call to <code>nextEvent</code> in the <code>execute</code> method. See <a class="el" href="tsm_8h.html">tsm.h</a>. The main advantage is that the only external interface to the HsmDefinition can be the EventQueue. Any "client" can asynchronously place an event in the event queue as long as they have a pointer to it. As soon as the HsmDefinition is done with its processing, it will pick up the first event in the queue and process it. This can be seen in the test/*.cpp files.</p>
<h4>Putting it all together</h4>
<p>Create your own state machine definition that derives from <code>HsmDefinition</code>. The Hsm hierarchy, its states (and sub-Hsms if any), events, actions and guards are all specified and defined in the definition. The relationships between Hsms and the state transition table is also specified here. All code related to your Hsm lives here. Then choose a policy class for your state machine. Create your own state machine type by wrapping the policy class around the <code>StateMachine</code> generic. The unit test provided below is illustrative.</p>
<div class="fragment"><div class="line">///</div><div class="line">/// GarageDoorDef is the state machine definition. It has knowledge of the Hsm</div><div class="line">/// hierarchy, its states, events and sub-Hsms if any. The relationships between</div><div class="line">/// Hsms (parentHsm_) is also setup here. Mix the Async observer and the</div><div class="line">/// GarageDoor HsmDefinition to get an asynchronous garage door state machine</div><div class="line">/// that notifies a listener at the end of processing each event.</div><div class="line">///</div><div class="line">using GarageDoorHsmSeparateThread =</div><div class="line">  AsyncBlockingObserver&lt;HsmExecutor&lt;GarageDoorDef&gt;&gt;;</div><div class="line"></div><div class="line">TEST_F(TestGarageDoorSM, testGarageDoorSeparateThreadPolicy)</div><div class="line">{</div><div class="line">    auto sm = std::make_shared&lt;GarageDoorHsmSeparateThread&gt;();</div><div class="line">    auto smDef = std::static_pointer_cast&lt;GarageDoorDef&gt;(sm);</div><div class="line"></div><div class="line">    sm-&gt;startSM();</div><div class="line"></div><div class="line">    sm-&gt;wait();</div><div class="line">    ASSERT_EQ(sm-&gt;getCurrentState(), &amp;smDef-&gt;doorClosed);</div><div class="line"></div><div class="line">    sm-&gt;sendEvent(smDef-&gt;click_event);</div><div class="line">    sm-&gt;wait();</div><div class="line">    ASSERT_EQ(sm-&gt;getCurrentState(), &amp;smDef-&gt;doorOpening);</div><div class="line"></div><div class="line">    sm-&gt;sendEvent(smDef-&gt;topSensor_event);</div><div class="line">    sm-&gt;wait();</div><div class="line">    ASSERT_EQ(sm-&gt;getCurrentState(), &amp;smDef-&gt;doorOpen);</div><div class="line"></div><div class="line">    sm-&gt;stopSM();</div><div class="line">}</div></div><!-- fragment --><h4>Testing</h4>
<p>For testing the <code>AsyncExecutionPolicy</code>, the <code>AsyncExecWithObserver</code> class is used with a special <code>Observer</code> class that blocks the parent thread until the <code>AsyncExecutionPolicy</code> finishes event processing. The state machine thread then calls a <code>notify</code> method that releases the mutex blocking the parent thread. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
