<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tsm: tsm Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tsm
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">tsm Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtsm_1_1AsyncExecutionPolicy.html">AsyncExecutionPolicy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtsm_1_1AsyncExecWithObserver.html">AsyncExecWithObserver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtsm_1_1BlockingObserver.html">BlockingObserver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtsm_1_1Event.html">Event</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtsm_1_1EventQueueT.html">EventQueueT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtsm_1_1Hsm.html">Hsm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtsm_1_1IHsm.html">IHsm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtsm_1_1MooreHsm.html">MooreHsm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtsm_1_1null__mutex.html">null_mutex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtsm_1_1OrthogonalHsm.html">OrthogonalHsm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtsm_1_1SingleThreadedExecutionPolicy.html">SingleThreadedExecutionPolicy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtsm_1_1State.html">State</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtsm_1_1StateTransitionTableT.html">StateTransitionTableT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtsm_1_1ThreadSleepTimer.html">ThreadSleepTimer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtsm_1_1TimedExecutionPolicy.html">TimedExecutionPolicy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8ab573af17042f875e8406c0d5d29fb8"><td class="memTemplParams" colspan="2">template&lt;typename Event &gt; </td></tr>
<tr class="memitem:a8ab573af17042f875e8406c0d5d29fb8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetsm.html#a8ab573af17042f875e8406c0d5d29fb8">SimpleEventQueue</a> = <a class="el" href="structtsm_1_1EventQueueT.html">EventQueueT</a>&lt; <a class="el" href="structtsm_1_1Event.html">Event</a>, <a class="el" href="structtsm_1_1null__mutex.html">null_mutex</a> &gt;</td></tr>
<tr class="separator:a8ab573af17042f875e8406c0d5d29fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03933a5ba08e2b42b53337dd429cf707"><td class="memTemplParams" colspan="2">template&lt;typename Event &gt; </td></tr>
<tr class="memitem:a03933a5ba08e2b42b53337dd429cf707"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetsm.html#a03933a5ba08e2b42b53337dd429cf707">EventQueue</a> = <a class="el" href="structtsm_1_1EventQueueT.html">EventQueueT</a>&lt; <a class="el" href="structtsm_1_1Event.html">Event</a>, std::mutex &gt;</td></tr>
<tr class="separator:a03933a5ba08e2b42b53337dd429cf707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6cca971bf6a22142c3aafc4d4022e7"><td class="memTemplParams" colspan="2">template&lt;typename Hsm &gt; </td></tr>
<tr class="memitem:a0a6cca971bf6a22142c3aafc4d4022e7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetsm.html#a0a6cca971bf6a22142c3aafc4d4022e7">SingleThreadedHsm</a> = <a class="el" href="structtsm_1_1SingleThreadedExecutionPolicy.html">SingleThreadedExecutionPolicy</a>&lt; <a class="el" href="structtsm_1_1Hsm.html">Hsm</a> &gt;</td></tr>
<tr class="separator:a0a6cca971bf6a22142c3aafc4d4022e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ab0669455fc993a98907a4347c9186"><td class="memTemplParams" colspan="2">template&lt;typename Hsm &gt; </td></tr>
<tr class="memitem:aa8ab0669455fc993a98907a4347c9186"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetsm.html#aa8ab0669455fc993a98907a4347c9186">AsynchronousHsm</a> = <a class="el" href="structtsm_1_1AsyncExecutionPolicy.html">AsyncExecutionPolicy</a>&lt; <a class="el" href="structtsm_1_1Hsm.html">Hsm</a> &gt;</td></tr>
<tr class="separator:aa8ab0669455fc993a98907a4347c9186"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5527e82e50cc1abdc75171dec877323b"><td class="memTemplParams" colspan="2">template&lt;class Tuple , class F , std::size_t... I&gt; </td></tr>
<tr class="memitem:a5527e82e50cc1abdc75171dec877323b"><td class="memTemplItemLeft" align="right" valign="top">constexpr F&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetsm.html#a5527e82e50cc1abdc75171dec877323b">for_each_impl</a> (Tuple &amp;&amp;t, F &amp;&amp;f, std::index_sequence&lt; I... &gt;)</td></tr>
<tr class="separator:a5527e82e50cc1abdc75171dec877323b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0c38c468a5a5b4a86c41af9ddfdaae"><td class="memTemplParams" colspan="2">template&lt;class Tuple , class F &gt; </td></tr>
<tr class="memitem:a4c0c38c468a5a5b4a86c41af9ddfdaae"><td class="memTemplItemLeft" align="right" valign="top">constexpr F&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetsm.html#a4c0c38c468a5a5b4a86c41af9ddfdaae">for_each_hsm</a> (Tuple &amp;&amp;t, F &amp;&amp;f)</td></tr>
<tr class="separator:a4c0c38c468a5a5b4a86c41af9ddfdaae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add71dd1c54296128b142a8104dc50bf1"><td class="memTemplParams" colspan="2">template&lt;typename Tuple , typename Predicate &gt; </td></tr>
<tr class="memitem:add71dd1c54296128b142a8104dc50bf1"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetsm.html#add71dd1c54296128b142a8104dc50bf1">find_if</a> (Tuple &amp;&amp;tuple, Predicate pred)</td></tr>
<tr class="separator:add71dd1c54296128b142a8104dc50bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93079b7715bed7ccc3ebf16effeebe9c"><td class="memTemplParams" colspan="2">template&lt;typename Tuple , typename Action &gt; </td></tr>
<tr class="memitem:a93079b7715bed7ccc3ebf16effeebe9c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetsm.html#a93079b7715bed7ccc3ebf16effeebe9c">perform</a> (Tuple &amp;&amp;tuple, size_t index, Action action)</td></tr>
<tr class="separator:a93079b7715bed7ccc3ebf16effeebe9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a8054214d46afc3867323bbf41a733511"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetsm.html#a8054214d46afc3867323bbf41a733511">counter_inc</a></td></tr>
<tr class="separator:a8054214d46afc3867323bbf41a733511"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The default policy class for asynchronous event processing. This policy is mixed in with a StateMachineT class to create an AsynchronousHsm. The client uses the sendEvent method to communicate with the state machine. A separate thread is created and blocks wating on events in the step method.</p>
<p>The policy for "synchronous" event processing. Events can be queued up in the event queue as they arrive. However, to process each event, a corresponding number of calls to the step function is required. So if there are 3 queued events, the step function needs to be invoked 3 times for all the events to be processed. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aa8ab0669455fc993a98907a4347c9186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ab0669455fc993a98907a4347c9186">&#9670;&nbsp;</a></span>AsynchronousHsm</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Hsm &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetsm.html#aa8ab0669455fc993a98907a4347c9186">tsm::AsynchronousHsm</a> = typedef <a class="el" href="structtsm_1_1AsyncExecutionPolicy.html">AsyncExecutionPolicy</a>&lt;<a class="el" href="structtsm_1_1Hsm.html">Hsm</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An Asynchronous state machine. <a class="el" href="structtsm_1_1Event.html">Event</a> processing is done in a separate thread. Usage is similar to SingleThreadedHsm above. The final call to "step" is not required. The state machine is blocked waiting on the next event to be processed. As soon as an event is sent to it (sendEvent), the client/parent thread returns and the event is processed in a separate thread. This design forces events to be immediately processed as soon as the HsmDefinition is done processing the previous event. It also simplifies the interface in that only one call to sendEvent is required. </p>

</div>
</div>
<a id="a03933a5ba08e2b42b53337dd429cf707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03933a5ba08e2b42b53337dd429cf707">&#9670;&nbsp;</a></span>EventQueue</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetsm.html#a03933a5ba08e2b42b53337dd429cf707">tsm::EventQueue</a> = typedef <a class="el" href="structtsm_1_1EventQueueT.html">EventQueueT</a>&lt;<a class="el" href="structtsm_1_1Event.html">Event</a>, std::mutex&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ab573af17042f875e8406c0d5d29fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab573af17042f875e8406c0d5d29fb8">&#9670;&nbsp;</a></span>SimpleEventQueue</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Event &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetsm.html#a8ab573af17042f875e8406c0d5d29fb8">tsm::SimpleEventQueue</a> = typedef <a class="el" href="structtsm_1_1EventQueueT.html">EventQueueT</a>&lt;<a class="el" href="structtsm_1_1Event.html">Event</a>, <a class="el" href="structtsm_1_1null__mutex.html">null_mutex</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a6cca971bf6a22142c3aafc4d4022e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a6cca971bf6a22142c3aafc4d4022e7">&#9670;&nbsp;</a></span>SingleThreadedHsm</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Hsm &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetsm.html#a0a6cca971bf6a22142c3aafc4d4022e7">tsm::SingleThreadedHsm</a> = typedef <a class="el" href="structtsm_1_1SingleThreadedExecutionPolicy.html">SingleThreadedExecutionPolicy</a>&lt;<a class="el" href="structtsm_1_1Hsm.html">Hsm</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A "simple" state machine. It executes in the context of the parent thread. The user is expected to instantiate this with their <a class="el" href="structtsm_1_1Hsm.html">Hsm</a> definition class. Use it like this:</p><ol type="1">
<li>The first step is to create your own state machine definition. struct MyHsmDef : HsmDefinition&lt;MyHsmDef&gt; { ... };</li>
<li>To create any statemachine, wrap an execution policy around the HsmDefinition generic defined in HsmExecutor.h. Here, SingleThreadedHsm is a mixin that combines the <a class="el" href="structtsm_1_1SingleThreadedExecutionPolicy.html">SingleThreadedExecutionPolicy</a> along with the HsmDefinition class; which in turn takes a state machine definition(HsmDef) as seen in the using statement below.</li>
<li>Now that you have your own SingleThreadedHsm, instantiate an object of your state machine type. SingleThreadedHsm&lt;MyHsmDef&gt; sm;</li>
<li>Send events to it using the sendEvent method. sm.sendEvent(sm.some_event);</li>
<li>To process the event, call the step method sm.step(); </li>
</ol>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="add71dd1c54296128b142a8104dc50bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add71dd1c54296128b142a8104dc50bf1">&#9670;&nbsp;</a></span>find_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tuple , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t tsm::find_if </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c0c38c468a5a5b4a86c41af9ddfdaae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0c38c468a5a5b4a86c41af9ddfdaae">&#9670;&nbsp;</a></span>for_each_hsm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Tuple , class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr F tsm::for_each_hsm </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5527e82e50cc1abdc75171dec877323b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5527e82e50cc1abdc75171dec877323b">&#9670;&nbsp;</a></span>for_each_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Tuple , class F , std::size_t... I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr F tsm::for_each_impl </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; I... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93079b7715bed7ccc3ebf16effeebe9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93079b7715bed7ccc3ebf16effeebe9c">&#9670;&nbsp;</a></span>perform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tuple , typename Action &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tsm::perform </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a8054214d46afc3867323bbf41a733511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8054214d46afc3867323bbf41a733511">&#9670;&nbsp;</a></span>counter_inc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto tsm::counter_inc</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= []() {</div>
<div class="line">    thread_local uint64_t a = 0;</div>
<div class="line">    <span class="keywordflow">return</span> ++a;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
